package validate

import (
	"errors"
	"fmt"
	"strings"
	"unicode"
)

const (
	minPassphraseWords uint = 2
	maxPassphraseWords uint = 128
)

// minWords and maxWords between 2 and 128
// nil word list, then we don't check wordlist
// separator can not be empty, contain space or just ASCII letters.
func Passphrase(passphrase string, minWords, maxWords uint, separator string, capitalize bool, number bool, wordList []string) error {
	// Ensure that maxWords is not less than minWords.
	if maxWords < minWords {
		return errors.New("maximum number of words allowed in the passphrase can not be less than minimum words allowed")
	}

	// Validate the number of words (must be between 2 and 128).
	if minWords < minPassphraseWords || maxWords > maxPassphraseWords {
		return fmt.Errorf("number of words must be between 2 and 128")
	}

	if separator == "" {
		return fmt.Errorf("empty separator can not be used for passphrase validation")
	}

	if strings.Contains(separator, " ") {
		return fmt.Errorf("separator can not be a space")
	}

	anyNonLetterCharacter := false

	for _, char := range separator {
		if !strings.ContainsRune(string(letterRunes), char) && unicode.IsPrint(char) {
			anyNonLetterCharacter = true
		}
	}

	if !anyNonLetterCharacter {
		return errors.New("separator only consists of ASCII letters")
	}

	passphraseWords := strings.Split(passphrase, separator)

	for _, word := range passphraseWords {
		if word == "" {
			return errors.New("separator is incorrect or passphrase doesn't have the raw format of passphrases generated by random.Passphrase() or pseudorandom.Passphrase() functions: there is an empty word in the splitted phassphrase")
		}
		for _, char := range specialRunes {
			if strings.HasPrefix(word, string(char)) || strings.HasSuffix(word, string(char)) {
				return fmt.Errorf("separator is incorrect or passphrase doesn't have the raw format of passphrases generated by random.Passphrase() or pseudorandom.Passphrase() functions: word \"%s\" has special character", word)
			}
		}
	}

	wordNumber := len(passphraseWords)

	if wordNumber < int(minWords) {
		return fmt.Errorf("number of word in passphrase %d is less than the minimum number of words allowed %d", wordNumber, minWords)
	}

	if wordNumber > int(maxWords) {
		return fmt.Errorf("number of word in passphrase %d is more than the maximum number of words allowed %d", wordNumber, maxWords)
	}

	if wordList != nil {
		wordMap := make(map[string]struct{}, len(wordList))

		for _, word := range wordList {
			wordMap[word] = struct{}{}
		}

		var wordListErrs []error

		for _, word := range passphraseWords {
			word = strings.TrimRight(word, "0123456789")
			word = strings.TrimLeft(word, "0123456789")
			word = strings.ToLower(word)
			_, ok := wordMap[word]
			if !ok {
				wordListErrs = append(wordListErrs, fmt.Errorf("word \"%s\" not in the specified word list", word))
			}
		}

		if len(wordListErrs) > 0 {
			return errors.Join(wordListErrs...)
		}
	}

	if capitalize {
		var capitalizeErrs []error
		for _, word := range passphraseWords {
			if strings.ContainsRune(string(lowerCaseRunes), []rune(word)[0]) {
				capitalizeErrs = append(capitalizeErrs, fmt.Errorf("word \"%s\" not capitalized", word))
			}
		}

		if len(capitalizeErrs) > 0 {
			return errors.Join(capitalizeErrs...)
		}
	}

	if number {
		anyNumber := false
		for _, word := range passphraseWords {
			if strings.ContainsRune(string(digitRunes), []rune(word)[len([]rune(word))-1]) {
				anyNumber = true
			}
		}

		if !anyNumber {
			return fmt.Errorf("there is no number at the end of any word")
		}
	}
	return nil
}
