package random

import (
	"crypto/rand"
	"errors"
	"fmt"
	"math/big"
	"strings"
)

const (
	maxPasswordLength uint = 4096
)

// Password generates a cryptographically-seucre random password of a length between the specified minLength and maxLength and complexity requirements from printable ASCII characters.
//
// Parameters:
//   - minLength: The minimum length of the password (up to 4096 characters).
//   - maxLength: The maximum length of the password (up to 4096 characters).
//   - lower: Whether to include lowercase letters.
//   - upper: Whether to include uppercase letters.
//   - digit: Whether to include digits.
//   - special: Whether to include special characters.
//
// Returns:
//   - A string containing the generated password.
//   - An error if the parameters are invalid.
//
// The minimum characters allowed for minLength and maxLength equls to the number of boolean requirements (lower, upper, digit, special) that are true. If all are false, the number is one.
//
// Try to avoid using special characters and passwords longer than 20 characters when you may import the password manually (For example passwords for OS user accounts in Linux/MacOS/Windows).
// In these situations, it would be better to use memorable passphrases generated by Passphrase function.
//  - Minimum Acceptable Password Length: 8 characters (According to NIST)
//  - Recommended Password Length: 20 characters or longer
//  - Safest Maximum Recommended Password Length: 32 characters
//  - Safe Maximum Recommended Password Length: 63 characters (Not for MySQL/MariaDB)
// Maximum Password Length:
//  - OpenSSH 255 characters
//  - Linux PAM 128 characters
//  - Windows 127 characters
//  - PostgreSQL 100 characters
//  - MySQL/MariaDB 32 characters
//  - GitHub 72 characters
//  - Facebook 200 characters
//  - Twitter 100 characters
//  - Google 100 characters
func Password(minLength, maxLength uint, lower bool, upper bool, digit bool, special bool) (string, error) {
	// Ensure that maxLength is not less than minLength.
	if maxLength < minLength {
		return "", errors.New("maximum length can not be less than minimum length")
	}

	var minPasswordLength uint

	if lower {
		minPasswordLength++
	}
	if upper {
		minPasswordLength++
	}
	if digit {
		minPasswordLength++
	}
	if special {
		minPasswordLength++
	}

	// If no requirement is true, password will have only ASCII lower case letters and the minimum length allowed for password is one.
	if !lower && !upper && !digit && !special {
		lower = true
		minPasswordLength = 1
	}

	// Validate that the length requirements fall within acceptable system bounds.
	if minLength < minPasswordLength {
		return "", fmt.Errorf("minimum password length must not be less than %d characters: the minimum characters allowed for minLength and maxLength equals to the number of boolean requirements (lower, upper, digit, special) that are true. If all are false, the number is one.", minPasswordLength)

	}

	if maxLength > maxPasswordLength {
		return "", fmt.Errorf("maximum password length must not exceed %d characters", maxPasswordLength)
	}

	// Determine the actual length of the password to be generated.
	random1, err := rand.Int(rand.Reader, big.NewInt(int64(maxLength - minLength + 1)))
	if err != nil {
		return "", fmt.Errorf("error generating a random number for calculating password length: %w", err)
	}
	length := int(random1.Int64()) + int(minLength)

	// Build the character set based on selected options.
	var allowedCharacters []rune
	if lower {
		allowedCharacters = append(allowedCharacters, lowerCaseRunes...)
	}
	if upper {
		allowedCharacters = append(allowedCharacters, upperCaseRunes...)
	}
	if digit {
		allowedCharacters = append(allowedCharacters, digitRunes...)
	}
	if special {
		allowedCharacters = append(allowedCharacters, specialRunes...)
	}

	// Create a rune slice to hold the generated password.
	password := make([]rune, length)

	// Loop until a valid password that meets the complexity requirements is generated.
	for {
		// Randomly generate the password using the allowed characters.
		for i := 0; i < int(length); i++ {
			random2, err := rand.Int(rand.Reader, big.NewInt(int64(len(allowedCharacters))))
			if err != nil {
				return "", fmt.Errorf("error generating a random index for selecting a character of password: %w", err)
			}
			password[i] = allowedCharacters[random2.Int64()]
		}

		// Flags to track whether the password meets the required complexity rules.
		hasOneLowercase := !lower
		hasOneUppercase := !upper
		hasOneDigit := !digit
		hasOneSpecial := !special

		// Validate the password's complexity by checking if it contains the required types of characters.
		for _, char := range password {
			switch {
			case strings.ContainsRune(string(lowerCaseRunes), char):
				hasOneLowercase = true
			case strings.ContainsRune(string(upperCaseRunes), char):
				hasOneUppercase = true
			case strings.ContainsRune(string(digitRunes), char):
				hasOneDigit = true
			case strings.ContainsRune(string(specialRunes), char):
				hasOneSpecial = true
			}
		}

		// If the password satisfies all complexity requirements, break out of the loop.
		if hasOneLowercase && hasOneUppercase && hasOneDigit && hasOneSpecial {
			break
		}

		// Otherwise, generate a new password in the next iteration.
	}

	return string(password), nil
}

// PasswordProfile defines the structure for specifying password complexity requirements for using in PasswordFor function.
type PasswordProfile struct {
	minLength  uint // Minimum number of characters required in the password.
	maxLength  uint // Maximum allowed number of characters in the password.
	hasLower   bool // Whether the password must include lowercase letters.
	hasUpper   bool // Whether the password must include uppercase letters.
	hasDigit   bool // Whether the password must include digits.
	hasSpecial bool // Whether the password must include special characters.
}

var (
	// Password profile for TLS CA key:
	//  - minLength: 20
	//  - maxLength: 255
	//  - hasLower: true
	//  - hasUpper: true
	//  - hasDigit: true
	//  - hasSpecial: true
	PasswordProfileTLSCAKey = PasswordProfile{minLength: 20, maxLength: 255, hasLower: true, hasUpper: true, hasDigit: true, hasSpecial: true}
	// Password Profile for SSH CA key:
	//  - minLength: 20
	//  - maxLength: 255
	//  - hasLower: true
	//  - hasUpper: true
	//  - hasDigit: true
	//  - hasSpecial: true
	PasswordProfileSSHCAKey = PasswordProfile{minLength: 20, maxLength: 255, hasLower: true, hasUpper: true, hasDigit: true, hasSpecial: true}
	// Password profile for TLS key:
	//  - minLength: 20
	//  - maxLength: 127
	//  - hasLower: true
	//  - hasUpper: true
	//  - hasDigit: true
	//  - hasSpecial: true
	PasswordProfileTLSKey = PasswordProfile{minLength: 20, maxLength: 127, hasLower: true, hasUpper: true, hasDigit: true, hasSpecial: true}
	// Password profile for SSH key:
	//  - minLength: 20
	//  - maxLength: 127
	//  - hasLower: true
	//  - hasUpper: true
	//  - hasDigit: true
	//  - hasSpecial: false
	PasswordProfileSSHKey = PasswordProfile{minLength: 20, maxLength: 127, hasLower: true, hasUpper: true, hasDigit: true, hasSpecial: false}
	// Password profile for Linux server user:
	//  - minLength: 20
	//  - maxLength: 63
	//  - hasLower: true
	//  - hasUpper: true
	//  - hasDigit: true
	//  - hasSpecial: false
	PasswordProfileLinuxServerUser = PasswordProfile{minLength: 20, maxLength: 63, hasLower: true, hasUpper: true, hasDigit: true, hasSpecial: false}
	// Password profile for Linux workstation user:
	//  - minLength: 10
	//  - maxLength: 20
	//  - hasLower: true
	//  - hasUpper: false
	//  - hasDigit: true
	//  - hasSpecial: false
	PasswordProfileLinuxWorkstationUser = PasswordProfile{minLength: 10, maxLength: 20, hasLower: true, hasUpper: false, hasDigit: true, hasSpecial: false}
	// Password profile for Windows server user:
	//  - minLength: 20
	//  - maxLength: 63
	//  - hasLower: true
	//  - hasUpper: true
	//  - hasDigit: true
	//  - hasSpecial: false
	PasswordProfileWindowsServerUser = PasswordProfile{minLength: 20, maxLength: 63, hasLower: true, hasUpper: true, hasDigit: true, hasSpecial: false}
	// Password profile for Windows desktop user:
	//  - minLength: 10
	//  - maxLength: 20
	//  - hasLower: true
	//  - hasUpper: false
	//  - hasDigit: true
	//  - hasSpecial: false
	PasswordProfileWindowsDesktopUser = PasswordProfile{minLength: 10, maxLength: 20, hasLower: true, hasUpper: false, hasDigit: true, hasSpecial: false}
	// 	Password profile for MariaDB
	//  - minLength: 20
	//  - maxLength: 31
	//  - hasLower: true
	//  - hasUpper: true
	//  - hasDigit: true
	//  - hasSpecial: false
	PasswordProfileMariaDB = PasswordProfile{minLength: 20, maxLength: 31, hasLower: true, hasUpper: true, hasDigit: true, hasSpecial: false}
)

// PasswordFor generates a cryptographically-secure random password based on a predefined profile.
// Parameters:
//   - profile: A PasswordProfile struct containing the configuration for the password.
//
// Returns:
//   - A string containing the generated password.
//   - An error if something goes wrong during password generation.
func PasswordFor(profile PasswordProfile) (string, error) {
	password, err := Password(profile.minLength, profile.maxLength, profile.hasLower, profile.hasUpper, profile.hasDigit, profile.hasSpecial)
	if err != nil {
		return "", fmt.Errorf("error generating a random password for profile: %w", err)
	}

	return password, nil
}
